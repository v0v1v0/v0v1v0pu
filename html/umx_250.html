<div class="container">

<table style="width: 100%;"><tr>
<td>umx_score_scale</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Score a psychometric scale by summing normal and reversed items.</h2>

<h3>Description</h3>

<p>Use this function to generate scores as the appropriate sum of responses to the normal and reversed items in a scale.
</p>
<p>Items must be named on the pattern <code>basename + N + suffix</code>, where <code>base</code> is the prefix common to all item (column) names, N is item number in the scale, and suffix an optional trail (like "_T1").
</p>
<p><code>pos</code> and <code>rev</code> are vectors of the item numbers for the normal and reverse-scored item numbers.
</p>
<p>To reverse items, the function uses <code>max</code> and <code>min</code> as the lowest and highest possible response scores to compute how to reverse items.
</p>
<p><em>note</em>: <code>min</code> defaults to 1.
<strong>TIP</strong>: If you have strings, <code>umx_score_scale</code> will work (use <code style="white-space: pre;">⁠mapStrings = ⁠</code>). <em>BUT</em> if you want to make a numeric copy, use <code>umx_strings2numeric</code>
</p>


<h3>Usage</h3>

<pre><code class="language-R">umx_score_scale(
  base = NULL,
  pos = NULL,
  rev = NULL,
  min = 1,
  max = NULL,
  data = NULL,
  score = c("total", "proportionCorrect", "errors", "mean", "max", "factor"),
  name = NULL,
  na.rm = TRUE,
  minManifests = NA,
  alpha = FALSE,
  mapStrings = NULL,
  correctAnswer = NULL,
  omegaNfactors = 1,
  digits = 2,
  verbose = FALSE,
  suffix = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>base</code></td>
<td>
<p>String common to all item names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pos</code></td>
<td>
<p>The positive-scored item numbers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rev</code></td>
<td>
<p>The reverse-scored item numbers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min</code></td>
<td>
<p>Minimum legal response value (default = 1). Not implemented for values other than 1 so far...</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max</code></td>
<td>
<p>Maximum legal response value (also used to compute reversed item values).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>The data frame</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>score</code></td>
<td>
<p>Score total (default), proportionCorrect, errors, mean, max, or factor scores</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>The name of the scale to be returned. Defaults to "<code>base</code>_score"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>Whether to delete NAs when computing scores (Default = TRUE) Note: Choice affects mean!</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minManifests</code></td>
<td>
<p>How many missing items to tolerate for an individual (when score = factor)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>print Reliability (omega and Cronbach's alpha) (TRUE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mapStrings</code></td>
<td>
<p>Recoding input like "No"/"Maybe"/"Yes" into numeric values (0,1,2)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>correctAnswer</code></td>
<td>
<p>Use when scoring items with one correct response (1/0).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omegaNfactors</code></td>
<td>
<p>Number of factors for the omega reliability (default = 1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>Rounding for omega etc. (default 2)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Whether to print the whole omega output (FALSE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suffix</code></td>
<td>
<p>(if dealing with, e.g. "_T1")</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In the presence of NAs, <code>score= "mean"</code> and <code>score = "totals"</code> both return NA unless na.rm = TRUE.
<code>score = "max"</code>, ignores NAs no matter what.
</p>


<h3>Value</h3>


<ul><li>
<p> scores
</p>
</li></ul>
<h3>References</h3>


<ul><li>
<p> Revelle, W. (2022) psych: Procedures for Personality and Psychological Research, Northwestern University, Evanston, Illinois, USA, <a href="https://CRAN.R-project.org/package=psych">https://CRAN.R-project.org/package=psych</a> Version = 2.2.9.
</p>
</li></ul>
<ul><li>
<p> McNeish, D. (2018). Thanks coefficient alpha, we’ll take it from here. <em>Psychological Methods</em>, <strong>23</strong>, 412-433. <a href="https://doi.org/10.1037/met0000144">doi:10.1037/met0000144</a>.
</p>
</li></ul>
<h3>See Also</h3>

<p>Other Data Functions: 
<code>noNAs()</code>,
<code>prolific_anonymize()</code>,
<code>prolific_check_ID()</code>,
<code>prolific_read_demog()</code>,
<code>umxFactor()</code>,
<code>umxHetCor()</code>,
<code>umx_as_numeric()</code>,
<code>umx_cont_2_quantiles()</code>,
<code>umx_lower2full()</code>,
<code>umx_make_MR_data()</code>,
<code>umx_make_TwinData()</code>,
<code>umx_make_fake_data()</code>,
<code>umx_make_raw_from_cov()</code>,
<code>umx_merge_randomized_columns()</code>,
<code>umx_polychoric()</code>,
<code>umx_polypairwise()</code>,
<code>umx_polytriowise()</code>,
<code>umx_read_lower()</code>,
<code>umx_rename()</code>,
<code>umx_reorder()</code>,
<code>umx_select_valid()</code>,
<code>umx_stack()</code>,
<code>umx_strings2numeric()</code>,
<code>umx</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(psych)
library(psychTools)
data(bfi)

# ==============================
# = Score Agreeableness totals =
# ==============================

# Handscore subject 1
# A1(R)+A2+A3+A4+A5 = (6+1)-2 +4+3+4+4 = 20

tmp = umx_score_scale(base = "A", pos = 2:5, rev = 1, max = 6, data= bfi, name = "A")
tmp[1, namez(tmp, "A",ignore.case = FALSE)]
#  A1 A2 A3 A4 A5  A
#  2  4  3  4  4  20

# ====================
# = Request the mean =
# ====================
tmp = umx_score_scale(name = "A", base = "A", 
   pos = 2:5, rev = 1, max = 6, data= bfi, score="mean")
tmp$A[1] # = 4

# ========================
# = Request factor score =
# ========================
## Not run: 
tmp = umx_score_scale(name = "A", base = "A", pos = 2:5, rev = 1,
   max = 6, score = "factor", minManifests = 4, data= bfi)
#            g
# A2 0.6574826
# A3 0.7581274
# A4 0.4814788
# A5 0.6272332
# A1 0.3736021

# ==================
# = Request alpha  =
# ==================

tmp=umx_score_scale(base="A", pos=2:5, rev=1, max=6, data=bfi, alpha=TRUE)
# omega t = 0.72

## End(Not run)

# ==================
# = na.rm = TRUE ! =
# ==================
tmpDF = bfi
tmpDF[1, "A1"] = NA
tmp = umx_score_scale("A", pos = 2:5, rev = 1, max = 6, data= tmpDF, score="mean")
tmp$A_score[1] # 3.75

tmp= umx_score_scale("A", pos= 2:5, rev= 1, max = 6, data = tmpDF,
   score="mean", na.rm=FALSE)
tmp$A_score[1] # NA (reject cases with missing items)

# ===============
# = Score = max =
# ===============
tmp = umx_score_scale("A", pos = 2:5, rev = 1, max = 6,
  data = bfi, name = "A", score = "max")
tmp$A[1] # Subject 1 max = 5 (reversed) item 1

# Default scale name
tmp = umx_score_scale("E", pos = 3:5, rev = 1:2, max = 6, 
   data= tmp, score = "mean", na.rm = FALSE)
tmp$E_score[1]

# Using @BillRevelle's psych package: More diagnostics, including alpha
scores= psych::scoreItems(items = bfi, min = 1, max = 6, keys = list(
	E = c("-E1","-E2", "E3", "E4", "E5"),
	A = c("-A1", "A2", "A3", "A4", "A5")
))
summary(scores)
scores$scores[1, ]
#  E   A 
# 3.8 4.0 

# Compare output
# (note, by default psych::scoreItems replaces NAs with the sample median...)
RevelleE = as.numeric(scores$scores[,"E"])
RevelleE == tmp[,"E_score"]

# =======================
# = MapStrings examples =
# =======================
mapStrings = c(
   "Very Inaccurate", "Moderately Inaccurate", 
   "Slightly Inaccurate", "Slightly Accurate",
   "Moderately Accurate", "Very Accurate")
bfi$As1 = factor(bfi$A1, levels = 1:6, labels = mapStrings)
bfi$As2 = factor(bfi$A2, levels = 1:6, labels = mapStrings)
bfi$As3 = factor(bfi$A3, levels = 1:6, labels = mapStrings)
bfi$As4 = factor(bfi$A4, levels = 1:6, labels = mapStrings)
bfi$As5 = factor(bfi$A5, levels = 1:6, labels = mapStrings)
bfi= umx_score_scale(name="A" , base="A", pos=2:5, rev=1, max=6, data=bfi)
bfi= umx_score_scale(name="As", base="As", pos=2:5, rev=1, mapStrings = mapStrings, data= bfi)
</code></pre>


</div>