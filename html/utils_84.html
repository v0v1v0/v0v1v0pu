<div class="container"><main><table style="width: 100%;"><tr>
<td>debugcall</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Debug a Call</h2>

<h3>Description</h3>

<p>Set or unset debugging flags based on a call to a function. Takes into
account S3/S4 method dispatch based on the classes of the arguments in
the call.
</p>


<h3>Usage</h3>

<pre><code class="language-R">debugcall(call, once = FALSE)
undebugcall(call)
</code></pre>


<h3>Arguments</h3>

<table>
<tr>
<td><code id="call">call</code></td>
<td>
<p>An R expression calling a function. The called function
will be debugged. See Details.</p>
</td>
</tr>
<tr>
<td><code id="once">once</code></td>
<td>
<p>logical; if <code>TRUE</code>, debugging only occurs once, as via
<code>debugonce</code>. Defaults to <code>FALSE</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>debugcall</code> debugs the non-generic function, S3 method or S4
method that would be called by evaluating <code>call</code>. Thus, the user
does not need to specify the signature when debugging
methods. Although the call is actually to the generic, it is the
method that is debugged, not the generic, except for non-standard S3
generics (see <code>isS3stdGeneric</code>).
</p>


<h3>Value</h3>

<p><code>debugcall</code> invisibly returns the debugged call expression.
</p>


<h3>Note</h3>

<p>Non-standard evaluation is used to retrieve the <code>call</code> (via
<code>substitute</code>). For this reason, passing a variable
containing a call expression, rather than the call expression itself,
will not work.
</p>


<h3>See Also</h3>

<p><code>debug</code> for the primary debugging interface
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
## Evaluate call after setting debugging
## 
f &lt;- factor(1:10)
res &lt;- eval(debugcall(summary(f))) 

## End(Not run)
</code></pre>

</main></div>