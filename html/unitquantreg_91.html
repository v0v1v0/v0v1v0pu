<div class="container">

<table style="width: 100%;"><tr>
<td>unitquantreg.control</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Control parameters for unit quantile regression</h2>

<h3>Description</h3>

<p>Auxiliary function that control fitting of unit quantile
regression models using <code>unitquantreg</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">unitquantreg.control(
  method = "BFGS",
  hessian = FALSE,
  gradient = TRUE,
  maxit = 5000,
  factr = 1e+07,
  reltol = sqrt(.Machine$double.eps),
  trace = 0L,
  starttests = FALSE,
  dowarn = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>string. Specify the method argument passed to <code>optimx</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessian</code></td>
<td>
<p>logical. Should use the numerically Hessian matrix to compute
variance-covariance? Default is <code>FALSE</code>, i.e., use the analytic
Hessian.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gradient</code></td>
<td>
<p>logical. Should use the analytic gradient? Default is
<code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>integer. Specify the maximal number of iterations passed to
<code>optimx</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>factr</code></td>
<td>
<p>numeric.Controls the convergence of the <code>"L-BFGS-B"</code> method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reltol</code></td>
<td>
<p>numeric. Relative convergence tolerance passed to <code>optimx</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>non-negative integer. If positive, tracing information on the
progress of the optimization is produced.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>starttests</code></td>
<td>
<p>logical. Should <code>optimx</code> run tests of the functions
and parameters? Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dowarn</code></td>
<td>
<p>logical. Show warnings generated by <code>optimx</code>? Default is
<code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed to <code>optimx</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>control</code> argument of
<code>unitquantreg</code> uses the arguments of
<code>unitquantreg.control</code>. In particular, the
parameters in <code>unitquantreg</code> are estimated by
maximum likelihood using the <code>optimx</code>, which is a
general-purpose optimization wrapper function that calls other R tools for
optimization, including the existing <code>optim</code> function.
The main advantage of <code>optimx</code> is to unify the tools
allowing a number of different optimization methods and provide sanity checks.
</p>


<h3>Value</h3>

<p>A list with components named as the arguments.
</p>


<h3>Author(s)</h3>

<p>André F. B. Menezes
</p>


<h3>References</h3>

<p>Nash, J. C. and Varadhan, R. (2011). Unifying Optimization Algorithms to Aid Software System Users: optimx for R., <em>Journal of Statistical Software</em>, <b>43</b>(9), 1–14.
</p>


<h3>See Also</h3>

<p><code>optimx</code> for more details about control
parameters and <code>unitquantreg.fit</code> the fitting
procedure used by <code>unitquantreg</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(sim_bounded, package = "unitquantreg")
sim_bounded_curr &lt;- sim_bounded[sim_bounded$family == "uweibull", ]

# Fitting using the analytical gradient
fit_gradient &lt;- unitquantreg(formula = y1 ~ x,
                             data = sim_bounded_curr, tau = 0.5,
                             family = "uweibull",
                             control = unitquantreg.control(gradient = TRUE,
                                                            trace = 1))

# Fitting without using the analytical gradient
fit_nogradient &lt;- unitquantreg(formula = y1 ~ x,
                             data = sim_bounded_curr, tau = 0.5,
                             family = "uweibull",
                             control = unitquantreg.control(gradient = FALSE,
                                                            trace = 1))
# Compare estimated coefficients
cbind(gradient = coef(fit_gradient), no_gradient = coef(fit_nogradient))

</code></pre>


</div>