<div class="container">

<table style="width: 100%;"><tr>
<td>umxPath</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Easier (and powerful) specification of paths in SEM.</h2>

<h3>Description</h3>

<p>This function is used to easily and compactly specify paths in models. In addition to
<code>from</code> and <code>to</code>, it adds specialised parameters for variances (var), two headed paths (with) and means (mean).
There are also new terms to describe fixing values: <code>fixedAt</code> and <code>fixFirst</code>.
To give a couple of the most common, time-saving examples:
</p>

<ul>
<li> <p><code>umxPath("A", with = "B",  fixedAt = 1)</code>
</p>
</li>
<li> <p><code>umxPath(var = c("A", "B"),  fixedAt = 1)</code>
</p>
</li>
<li> <p><code>umxPath(v.m. = manifests)</code>
</p>
</li>
<li> <p><code>umxPath(v1m0 = latents)</code>
</p>
</li>
<li> <p><code>umxPath(v1m0 = latents)</code>
</p>
</li>
<li> <p><code>umxPath(means = manifests)</code>
</p>
</li>
<li> <p><code>umxPath(fromEach = c('A',"B","C"), to = c("y1","y2"))</code>
</p>
</li>
<li> <p><code>umxPath(unique.bivariate = c('A',"B","C"))</code>
</p>
</li>
<li> <p><code>umxPath("A", to = c("B","C","D"),  firstAt = 1)</code>
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">umxPath(
  from = NULL,
  to = NULL,
  with = NULL,
  var = NULL,
  cov = NULL,
  means = NULL,
  v1m0 = NULL,
  v.m. = NULL,
  v0m0 = NULL,
  v.m0 = NULL,
  v0m. = NULL,
  fixedAt = NULL,
  freeAt = NULL,
  firstAt = NULL,
  unique.bivariate = NULL,
  unique.pairs = NULL,
  fromEach = NULL,
  forms = NULL,
  Cholesky = NULL,
  defn = NULL,
  connect = c("single", "all.pairs", "all.bivariate", "unique.pairs", "unique.bivariate"),
  arrows = 1,
  free = TRUE,
  values = NA,
  labels = NA,
  lbound = NA,
  ubound = NA,
  hasMeans = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>from</code></td>
<td>
<p>One or more source variables e.g "A" or c("A","B")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to</code></td>
<td>
<p>One or more target variables for one-headed paths, e.g "A" or c("A","B").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>with</code></td>
<td>
<p>2-headed path &lt;–&gt; from 'from' to 'with'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var</code></td>
<td>
<p>Equivalent to setting 'from' and 'arrows' = 2. nb: from, to, and with must be left empty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov</code></td>
<td>
<p>Convenience to allow 2 variables to covary (equivalent to 'from' and 'with'). nb: leave from, to, etc. empty</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>means</code></td>
<td>
<p>equivalent to "from = 'one', to = x. nb: from, to, with and var must be left empty (their default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v1m0</code></td>
<td>
<p>variance of 1 and mean of zero in one call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v.m.</code></td>
<td>
<p>variance and mean, both free.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v0m0</code></td>
<td>
<p>variance and mean, both fixed at zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v.m0</code></td>
<td>
<p>variance free, mean fixed at zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v0m.</code></td>
<td>
<p>variance fixed at 0, mean free.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixedAt</code></td>
<td>
<p>Equivalent to setting "free = FALSE, values = fixedAt"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>freeAt</code></td>
<td>
<p>Equivalent to setting "free = TRUE, values = freeAt"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>firstAt</code></td>
<td>
<p>First path is fixed at this value (free is ignored: warning if other than a single TRUE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unique.bivariate</code></td>
<td>
<p>equivalent to setting from, and "connect = "unique.bivariate", arrows = 2".
nb: from, to, and with must be left empty (their default)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unique.pairs</code></td>
<td>
<p>equivalent to setting "connect = "unique.pairs", arrows = 2" (don't use from, to, or with)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fromEach</code></td>
<td>
<p>Like all.bivariate, but with one head arrows. 'to' can be set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>forms</code></td>
<td>
<p>Build a formative variable. 'from' variables form the latent.
Latent variance is fixed at 0. Loading of path 1 is fixed at 1. unique.bivariate between 'from' variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Cholesky</code></td>
<td>
<p>Treat <strong>Cholesky</strong> variables as latent and <strong>to</strong> as measured, and connect as in an ACE model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>defn</code></td>
<td>
<p>Implements a definition variable as a latent with zero variance &amp; mean and labeled 'data.defVar'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>connect</code></td>
<td>
<p>as in mxPath - nb: from and to must also be set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arrows</code></td>
<td>
<p>as in mxPath - nb: from and to must also be set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>free</code></td>
<td>
<p>whether the value is free to be optimised</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>values</code></td>
<td>
<p>default value list</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels</code></td>
<td>
<p>labels for each path</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lbound</code></td>
<td>
<p>lower bounds for each path value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ubound</code></td>
<td>
<p>upper bounds for each path value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hasMeans</code></td>
<td>
<p>Used in 'forms' case to know whether the data have means or not.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>umxPath</code> introduces the following new words to your path-defining vocabulary: <code>with</code>, <code>var</code>, <code>cov</code>, <code>means</code>, <code>v1m0</code>,
<code>v0m0</code>, <code>v.m0</code>, <code>v.m</code>, <code>fixedAt</code>, <code>freeAt</code>, <code>firstAt</code>, <code>unique.bivariate</code>, <code>unique.pairs</code>, <code>fromEach</code>, <code>Cholesky</code>, <code>defn</code>, <code>forms</code>.
</p>
<p><code>with</code> creates covariances (2-headed paths):
<code>umxPath(A, with = B)</code>
</p>
<p>Specify a variance for A with
<code>umxPath(var = "A")</code>.
</p>
<p>Of course you can use vectors anywhere:
<code>umxPath(var = c('N','E', 'O'))</code>
</p>
<p>To specify a mean, you just say:
<code>umxPath(mean = "A")</code>, which is equivalent to <code>mxPath(from = "one", to = "A")</code>.
</p>
<p>To fix a path at a value, you can say:
<code>umxPath(var = "A", fixedAt = 1)</code>
</p>
<p>The common task of creating a variable with variance fixed at 1 and mean at 0 is done thus:
<code>umxPath(v1m0 = "A")</code>
</p>
<p>For free variance and means use:
<code>umxPath(v.m. = "A")</code>
</p>
<p><code>umxPath</code> exposes <code>unique.bivariate</code> and <code>unique.pairs</code>, So to create paths A&lt;-&gt;A, B&lt;-&gt;B,
and A-&gt;B, you would say:
<code>umxPath(unique.pairs = c('A',"B"))</code>
</p>
<p>To create paths A&lt;-&gt;B, B&lt;-&gt;C, and A&lt;-&gt;C, you would say:
<code>umxPath(unique.bivariate = c('A',"B","C"))</code>
</p>
<p>Creates one-headed arrows on the all.bivariate pattern
<code>umxPath(fromEach = c('A',"B","C"))</code>
</p>
<p>Setting up a latent trait, you can scale with a fixed first path thus:
</p>
<p><code>umxPath("A", to = c("B","C","D"),  firstAt = 1)</code>
</p>
<p>To create Cholesky-pattern connections:
</p>
<p><code style="white-space: pre;">⁠umxPath(Cholesky = c("A1", "A2"), to c("var1", "var2"))⁠</code>
</p>


<h3>Value</h3>


<ul><li>
<p> 1 or more <code>mxPath()</code>s
</p>
</li></ul>
<h3>References</h3>


<ul><li> <p><a href="https://tbates.github.io">https://tbates.github.io</a>
</p>
</li></ul>
<h3>See Also</h3>


<ul><li> <p><code>mxPath()</code>
</p>
</li></ul>
<p>Other Core Model Building Functions: 
<code>umxMatrix()</code>,
<code>umxModify()</code>,
<code>umxRAM()</code>,
<code>umxSuperModel()</code>,
<code>umx</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# ==========================================
# = Examples of each path type, and option =
# ==========================================

umxPath("A", to = "B") # One-headed path from A to B
umxPath("A", to = "B", fixedAt = 1) # same, with value fixed @1
umxPath("A", to = c("B", "C"), fixedAt = 1:2) # same, with more than 1 value
umxPath("A", to = c("B","C"), firstAt = 1) # Fix only the first path, others free
umxPath(var = "A") # Give a variance to A
umxPath(var = "A", fixedAt = 1) # Give A variance, fixed at 1
umxPath(means = c("A","B")) # Create a means model for A: from = "one", to = "A"
umxPath(v1m0 = "A") # Give "A" variance and a mean, fixed at 1 and 0 respectively
umxPath(v.m. = "A") # Give "A" variance and a mean, leaving both free.
umxPath(v0m0 = "W", label = c(NA, "data.W"))
umxPath("A", with = "B") # using with: same as "to = B, arrows = 2"
umxPath("A", with = "B", fixedAt = .5) # 2-head path fixed at .5
umxPath("A", with = c("B", "C"), firstAt = 1) # first covariance fixed at 1
umxPath(cov = c("A", "B"))  # Covariance A &lt;-&gt; B
umxPath(defn = "mpg") # create latent called def_mpg, with var = 1 and label = "data.mpg"
umxPath(fromEach = c('a','b'), to = c('c','d')) # a-&gt;c, a&lt;-&gt;d, b&lt;-&gt;c, b&lt;-&gt;d
umxPath(unique.bivariate = c('a','b','c')) # bivariate paths a&lt;-&gt;b, a&lt;-&gt;c, b&lt;-&gt;c etc.
umxPath(unique.pairs = letters[1:3]) # all distinct pairs: a&lt;-&gt;a, a&lt;-&gt;b, a&lt;-&gt;c, b&lt;-&gt;b, etc.
umxPath(Cholesky = c("A1","A2"), to = c("m1", "m2")) # Cholesky

## Not run: 
# A worked example
data(demoOneFactor)
manifests = names(demoOneFactor)
m1 = umxRAM("One Factor", data = demoOneFactor, type= "cov",
	umxPath("G", to = manifests),
	umxPath(var = manifests),
	umxPath(var = "G", fixedAt = 1.0)
)
umxSummary(m1, std = TRUE)
require(umx)


# ====================
# = Cholesky example =
# ====================
# ======================================================================
# = 3-factor Cholesky (A component of a 5-variable 3-factor ACE model) =
# ======================================================================
latents   = paste0("A", 1:3)
manifests = names(demoOneFactor)
m1 = umxRAM("Chol", data = demoOneFactor, type = "cov",
	umxPath(Cholesky = latents, to = manifests),
	umxPath(var = manifests),
	umxPath(var = latents, fixedAt = 1)
)
plot(m1, splines= FALSE)

# ======================================================================
# = Definition variable example. for a RAM model                       =
# = def vars are instantiated as dummy latents with data on the "mean" = 
# ======================================================================
library(umx); libs("MASS") # for mvrnorm()
# 1. Create Data
N = 500 # size of each group
Sigma  = matrix(c(1,.5,.5,1),2,2) # cov (.5)
group1 = MASS::mvrnorm(N, c(1,2), Sigma)
group2 = MASS::mvrnorm(N, c(0,0), Sigma)
# rbind groups and name cols "x" and "y"
xy = rbind(group1, group2)
dimnames(xy)[2]= list(c("x", "y"))

# Create a definition variable for group status
groupID = rep(c(1,0), each = N) 
df = data.frame(xy, groupID = groupID)

# Make the model with a definition variable on means
m1 = umxRAM("Def Means", data = df,
	umxPath(v.m. = c("x","y")),
	umxPath("x", with = "y"),
 # create a unit latent called "def_groupID" with data "data.groupID"
	umxPath(defn = "groupID"),
 # Add it to the x and y means
	umxPath("def_groupID", to = c("x", "y"))
)
plot(m1)


## End(Not run)
</code></pre>


</div>